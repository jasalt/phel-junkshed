(ns js\cli
  (:require phel\str)
  (:require js\validate-opts :refer [validate-opts])
  (:require js\introspection :refer [get-min-arity get-arity variadic?])
  )

;; Phel utilities for command line interfaces
;; Loosely inspired by:
;; - https://github.com/babashka/cli
;; - https://github.com/nextjournal/garden-cli/blob/8cbd0a719c7d0999dee93cb1e9e5387cb5e9ab1a/src/nextjournal/garden_cli.clj

(defn- parse-farg-tokens [s]
  (loop [chars (php->phel (php/mb_str_split s))
         current ""
         tokens []
         in-quotes nil
         escaped false]
    (cond
      (empty? chars)
      (if (empty? current)
        tokens
        (push tokens current))

      escaped
      (recur (rest chars)
             (str current (first chars))
             tokens
             in-quotes
             false)

      (= (first chars) "\\" )
      (if (and in-quotes
               (not (empty? (rest chars)))
               (= (first (rest chars)) "\\"))
        ;; Handle double backslash inside quotes - convert to single backslash
        (recur (rest (rest chars))
               (str current "\\")
               tokens
               in-quotes
               false)
        ;; Single backslash handling
        (if in-quotes
          ;; Inside quotes: only escape quote characters, preserve other backslashes literally
          (if (and (not (empty? (rest chars)))
                   (= (first (rest chars)) in-quotes))
            ;; Escaping the quote character
            (recur (rest chars)
                   current
                   tokens
                   in-quotes
                   true)
            ;; Literal backslash, preserve it
            (recur (rest chars)
                   (str current "\\")
                   tokens
                   in-quotes
                   false))
          ;; Outside quotes: escape any character (like spaces)
          (recur (rest chars)
                 current
                 tokens
                 in-quotes
                 true)))

      (and (nil? in-quotes) (or (= (first chars) "\"") (= (first chars) "'")))
      (recur (rest chars)
             current
             tokens
             (first chars)
             false)

      (and in-quotes (= (first chars) in-quotes))
      (recur (rest chars)
             current
             tokens
             nil
             false)

      (and (nil? in-quotes) (= (first chars) " "))
      (if (empty? current)
        (recur (rest chars) "" tokens nil false)
        (recur (rest chars) "" (push tokens current) nil false))

      :else
      (recur (rest chars)
             (str current (first chars))
             tokens
             in-quotes
             false))))

(defn- parse-farg-token [token]
  (if (str/includes? token "=")
    (let [[key val] (str/split token "/=/" 2)]
      [(keyword (str/replace key "/--/" ""))
       (if (empty? val) true val)])
    [(keyword (str/replace token "/--/" "")) true]))

(defn parse-flag-args
  "Parses command line flag arguments into map.
  Flag argument without value set defaults to value being true.
  Time per call ~4.5ms."
  [s]
  (let [tokens (parse-farg-tokens s)]
    (reduce (fn [acc token]
              (let [[key val] (parse-farg-token token)]
                (assoc acc key val)))
            {}
            tokens)))

;; TESTS
(comment
  (and
   (= (parse-flag-args
       "--foo=\"two bar\" --baz=123")
      {:foo "two bar" :baz "123"})

   (= (parse-flag-args
       "--foo=\"two bar\" --baz=123 --parsing")
      {:foo "two bar" :baz "123" :parsing true})

   (= (parse-flag-args
       "--foo=\"two bar\" --baz=123 --parsing --more")
      {:foo "two bar" :baz "123" :parsing true :more true})

   (= (parse-flag-args
       "--foo=\"two bar\" --baz=123 --parsing --more --harder=definitely")
      {:foo "two bar" :baz "123" :parsing true :more true :harder "definitely"})

   (= (parse-flag-args
       "--foo=\"two bar\" --baz=123 --parsing GLITCH --harder=definitely")
      {:foo "two bar" :baz "123" :parsing true :GLITCH true :harder "definitely"})

   (= (parse-flag-args
       "--path=~/Home/Old\ Program\ Files")
      {:path "~/Home/Old Program Files"})

   (= (parse-flag-args
       "--backslash-maddness=\"Phel\\Compiler\\Domain\\Emitter\\OutputEmitter\\NodeEmitter\"")
      {:backslash-maddness "Phel\\Compiler\\Domain\\Emitter\\OutputEmitter\\NodeEmitter"})

   ;; Empty string
   (= (parse-flag-args "")
      {})

   ;; Only spaces
   (= (parse-flag-args "   ")
      {})

   ;; Single flag with no value
   (= (parse-flag-args "--flag")
      {:flag true})

   ;; Single quotes
   (= (parse-flag-args "--single='hello world'")
      {:single "hello world"})

   ;; Mixed quotes (should not match)
   (= (parse-flag-args "--mixed=\"hello'")
      {:mixed "hello'"})

   ;; Unmatched quotes - opening quote only  ! (?)
   (= (parse-flag-args "--unmatched=\"hello world")
      {:unmatched "hello world"})

   ;; Multiple equals signs
   (= (parse-flag-args "--url=http://example.com/path?a=1&b=2")
      {:url "http://example.com/path?a=1&b=2"})

   ;; Consecutive spaces
   (= (parse-flag-args "--flag1    --flag2")
      {:flag1 true :flag2 true})

   ;; Special characters in values
   (= (parse-flag-args "--special=\"!@#$%^&*()\"")
      {:special "!@#$%^&*()"})

   ;; Escaped quote in middle
   (= (parse-flag-args "--escaped=\"say \\\"hello\\\" world\"")
      {:escaped "say \"hello\" world"})

   ;; Multiple backslashes
   (= (parse-flag-args "--multi=\"\\\\\\\\\"")
      {:multi "\\\\"})

   ;; Tab and newline characters (if supported)
   (= (parse-flag-args "--whitespace=\"tab\there\nnewline\"")
      {:whitespace "tab\there\nnewline"})

   ;; Unicode characters
   (= (parse-flag-args "--unicode=\"café naïve résumé\"")
      {:unicode "café naïve résumé"})

   ;; Flag name with special characters
   (= (parse-flag-args "--flag-with-dashes=value")
      {:flag-with-dashes "value"})

   ;; Numbers as values
   (= (parse-flag-args "--number=42 --float=3.14 --negative=-5")
      {:number "42" :float "3.14" :negative "-5"})
   )

  ;; TODO failing tests, setup test runner properly before fix

  ;; Spaces around equals
  (= (parse-flag-args "--spaced = value")  ; => {:spaced true : true :value true}
     {:spaced true := true :value true})

  ;; Backslash at end of quoted string
  (= (parse-flag-args "--trailing=\"path\\\"")  ; => {:trailing "path\""}
     {:trailing "path\\"})

  ;; Empty quotes  !
  (= (parse-flag-args "--empty=\"\"")  ; => {:empty true}
     {:empty ""})
  )

(defn- verify-arity
  "Validates the `param-count` for given function `f`.
  Throws on mismatch, returns true otherwise."
  [f param-count]
  (let [min-arity (get-min-arity f)
        arity (get-arity f)
        variadic (variadic? f)]

    (when (< param-count min-arity)
      (throw (php/new \InvalidArgumentException
                      (str "Not enough parameters passed via CLI, required "
                           min-arity (when variadic " or more for the function"
                                           " (all flag arguments counted as one)")))))

    (when (and (> param-count arity) (not variadic))
      (throw (php/new \InvalidArgumentException
                      (str "Too many parameters passed via CLI, maximum "
                           min-arity (when variadic " or more")
                           " (all flag arguments counted as one)"))))
    #_(println "Function min-arity:" min-arity "arity:" arity "variadic:" variadic))
  true)


(defn- prepare-fn
  "Prepares given function applying parsed cli-args to it. One or more positional
  args can be passed before flag arguments, flag arguments are collected into a
  map as the last argument."
  [f cli-args & [opts-spec]]
  (let [[positional flags] (split-with |(not (str/starts-with? $ "-")) cli-args)
        flags-map (parse-flag-args (str/join " " flags))
        the-params (if-not (empty? flags-map) (push positional flags-map)
                           positional)]
    (println "the-params" the-params)
    (when opts-spec
      (println "Validating opts for spec" opts-spec)
      (validate-opts opts-spec flags-map))

    (verify-arity f (count the-params))

    (fn [] (apply f the-params))))

(defn resolve-command
  "Resolve command function from commands map and return it with rest of args
  applied as function parameters. Supports function defined directly in map or
  as nested map with :handler"
  [commands cli-args]
  (loop [args cli-args
         matched-command []]
    (when-not (empty? args)
      (let [lookup (push matched-command
                         (keyword (first args)))
            lookup-value (get-in commands lookup)  ; OPTIMIZE: traverse once
            ;; Check if item is a map and has :handler key returning it's value
            lookup-function (when (hash-map? lookup-value)
                              (let [matched-item (:handler lookup-value)]
                                (when (function? matched-item)
                                  matched-item)))
            opts-spec (when lookup-function (:spec lookup-value))]
        (cond
          ;; Check for a nested map with :handler function
          lookup-function
          (prepare-fn lookup-function (rest args) opts-spec)

          ;; Check for a plain function
          (function? lookup-value)
          (prepare-fn lookup-value (rest args))

          ;; Match not found yet, traverse further
          (hash-map? lookup-value) (recur (rest args) lookup))))))

;; TODO if command defined as map, check if it contains :spec, and do validation according to it
;;      otherwise validate argument count using reflection (min-arity / max-arity)

(comment
  (function? (resolve-command
              {:tables {:create (fn [] 1)
                        :drop   (fn [] 2)}}
              ["tables" "create" "bar" "foo=1"]))  ; TODO should give \InvalidArgumentException for incorrect arity or check for spec

  (function? (resolve-command
              {:tables {:create {:handler (fn [] 1)}
                        :drop   (fn [] 2)}}
              ["tables" "create"]))

  (nil? (resolve-command
         {:tables {:create (fn [] 1)
                   :drop   (fn [] 2)}}
         ["tables" "created"]))

  ;;  Test invocation

  (let [the-applied-fn
        (resolve-command
         {:addition
          {:of-two
           {:handler (fn [first second]
                       (+ (php/intval first)
                          (php/intval second)))}}}
         ["addition" "of-two" "1" "2"])]
    (= 3 (the-applied-fn)))

  (let [the-applied-fn
        (resolve-command
         {:addition
          {:of-two
           {:handler (fn [opts]
                       (+ (php/intval (:first opts))
                          (php/intval (:second opts))))}}}
         ["addition" "of-two" "--first=3" "--second=2"])]
    (= 5 (the-applied-fn)))

  (let [the-applied-fn
        (resolve-command
         {:addition
          {:of-two
           {:spec {:first  {:require true :validate '(fn [x] (pos? (php/intval x)))}
                   :second {:require true :validate '(fn [x] (pos? (php/intval x)))}}
            :handler (fn [opts]
                       (+ (php/intval (:first opts))
                          (php/intval (:second opts))))}
           }
          }
         ["addition" "of-two" "--first=3" "--second=2"])]
    (= 5 (the-applied-fn)))



  (function?
   (resolve-command
    {:fun
     {:two-arity (fn [a b] (println "got: " a b))}}
    ["fun" "two-arity" "one" "two"]))

  ;; Throws
  (resolve-command
    {:fun
     {:two-arity (fn [a b] (println "got: " a b))}}
    ["fun" "two-arity" "one"])

  (resolve-command
    {:fun
     {:two-arity (fn [a b] (println "got: " a b))}}
    ["fun" "two-arity"])

  (resolve-command
    {:fun
     {:two-arity (fn [a b] (println "got: " a b))}}
    ["fun" "two-arity" "one" "two" "three"])
)
